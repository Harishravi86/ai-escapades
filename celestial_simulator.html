<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Celestial Simulator v5 - Vector Physics Engine</title>
    <style>
        :root {
            --bg-color: #050510;
            --card-bg: #1a1a2e;
            --accent: #3b82f6;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: #02020a;
            color: #e2e8f0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            padding: 12px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Layout */
        .grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }

        @media (min-width: 1024px) {
            .grid {
                grid-template-columns: 3fr 1fr;
            }
        }

        /* UI Components */
        .card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid #2d2d42;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
        }

        .header {
            text-align: center;
            margin-bottom: 16px;
            position: relative;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(to right, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Controls */
        button {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button:hover {
            filter: brightness(1.2);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
            box-shadow: 0 2px 10px rgba(59, 130, 246, 0.3);
        }

        .btn-secondary {
            background: #334155;
            color: #cbd5e1;
        }

        .btn-yellow {
            background: #b45309;
            color: white;
        }

        .btn-cyan {
            background: #0e7490;
            color: white;
        }

        .btn-outline {
            background: transparent;
            border: 1px solid #475569;
            color: #94a3b8;
        }

        .btn-outline.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }

        input,
        select {
            padding: 6px 10px;
            border: 1px solid #334155;
            border-radius: 6px;
            background: #0f172a;
            color: white;
            font-size: 13px;
            outline: none;
            color-scheme: dark;
        }

        input[type="date"]::-webkit-calendar-picker-indicator {
            cursor: pointer;
            filter: invert(1);
            opacity: 0.6;
        }

        input[type="date"]::-webkit-calendar-picker-indicator:hover {
            opacity: 1;
        }

        /* Displays */
        .date-display {
            font-size: 28px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-align: center;
            padding: 12px;
            background: #0f172a;
            border-radius: 8px;
            margin-bottom: 12px;
            border: 1px solid #1e293b;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }

        .era-badge {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 12px;
            font-family: sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Visualization Area */
        .sim-container {
            position: relative;
            aspect-ratio: 1/1;
            max-height: 600px;
            margin: 0 auto;
        }

        .orbital-container {
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1e1e2f 0%, #050510 70%);
            border-radius: 50%;
            border: 1px solid #2d2d42;
            position: relative;
            overflow: hidden;
        }

        /* SVG Elements */
        text {
            font-family: sans-serif;
            pointer-events: none;
            text-shadow: 0 2px 4px black;
        }

        .planet-circle {
            transition: r 0.2s;
            cursor: pointer;
        }

        .planet-circle:hover {
            r: 8 !important;
            stroke: white;
            stroke-width: 2px;
        }

        .orbit-path {
            fill: none;
            stroke: #334155;
            stroke-width: 1;
            stroke-dasharray: 4, 4;
            opacity: 0.3;
        }

        .trail {
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
            pointer-events: none;
            mix-blend-mode: screen;
        }

        /* Sidebar Elements */
        .panel-section {
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid #2d2d42;
        }

        .panel-section:last-child {
            border: none;
        }

        .panel-title {
            font-size: 12px;
            text-transform: uppercase;
            color: #94a3b8;
            margin-bottom: 8px;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .sep-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .sep-box {
            background: #0f172a;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #1e293b;
            transition: all 0.3s;
        }

        .sep-box.active {
            border-color: #fbbf24;
            background: rgba(251, 191, 36, 0.1);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.1);
        }

        .sep-val {
            font-size: 20px;
            font-family: monospace;
            font-weight: bold;
        }

        .event-list {
            max-height: 300px;
            overflow-y: auto;
            padding-right: 4px;
        }

        .event-item {
            padding: 8px;
            margin-bottom: 4px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            background: #222238;
            border-left: 2px solid transparent;
            transition: all 0.2s;
        }

        .event-item:hover {
            background: #2d2d48;
            transform: translateX(2px);
        }

        .event-item.active {
            background: #312e81;
            border-left-color: #818cf8;
        }

        .event-item.sun {
            border-left-color: #fbbf24;
        }

        .event-item.moon {
            border-left-color: #22d3ee;
        }

        /* Tooltip */
        #tooltip {
            position: absolute;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #475569;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            color: white;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.2s;
        }

        /* Timeline */
        input[type=range] {
            width: 100%;
            height: 6px;
            background: #334155;
            border-radius: 3px;
            -webkit-appearance: none;
            cursor: pointer;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #3b82f6;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
            margin-top: -5px;
        }

        input[type=range]::-moz-range-track {
            width: 100%;
            height: 6px;
            background: #334155;
            border-radius: 3px;
        }

        /* Retrograde Indicator */
        .retro-badge {
            font-size: 10px;
            background: #ef4444;
            color: white;
            padding: 1px 4px;
            border-radius: 3px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .retro-badge.visible {
            opacity: 1;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #0f172a;
        }

        ::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #475569;
        }
    </style>
</head>

<body>

    <div class="container">
        <div class="header">
            <h1>Celestial Engine v5.0</h1>
            <p style="color: #64748b; font-size: 13px;">Vector Physics • Retrograde Accurate • 1900-2050</p>
        </div>

        <div class="grid">
            <div class="card">
                <div
                    style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; flex-wrap: wrap; gap: 10px;">
                    <div style="display: flex; gap: 4px;">
                        <button class="btn-outline active" id="viewGeo" onclick="setViewMode('geo')">Geocentric</button>
                        <button class="btn-outline" id="viewHelio" onclick="setViewMode('helio')">Heliocentric</button>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <span style="font-size: 11px; color: #94a3b8;">Trails:</span>
                        <select onchange="setTrailLength(this.value)" style="width: 80px;">
                            <option value="0">Off</option>
                            <option value="50">Short</option>
                            <option value="150" selected>Medium</option>
                            <option value="400">Long</option>
                        </select>
                    </div>
                </div>

                <div class="date-display">
                    <span id="dateDisplay"></span>
                    <span id="eraBadge" class="era-badge" style="background: #334155;">-</span>
                </div>

                <div class="sim-container">
                    <div id="tooltip"></div>
                    <div class="orbital-container">
                        <svg id="solarSystem" viewBox="0 0 1000 1000" style="width: 100%; height: 100%;">
                            <defs>
                                <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                                    <feGaussianBlur stdDeviation="4" result="coloredBlur" />
                                    <feMerge>
                                        <feMergeNode in="coloredBlur" />
                                        <feMergeNode in="SourceGraphic" />
                                    </feMerge>
                                </filter>
                                <radialGradient id="sunGradient">
                                    <stop offset="0%" stop-color="#fff" />
                                    <stop offset="20%" stop-color="#fcd34d" />
                                    <stop offset="100%" stop-color="#f59e0b" stop-opacity="0.8" />
                                </radialGradient>
                            </defs>

                            <g id="starsLayer"></g>
                            <circle cx="500" cy="500" r="480" stroke="#1e293b" stroke-width="40" fill="none"
                                opacity="0.5" />
                            <g id="zodiacLayer"></g>
                            <g id="gridLayer" opacity="0.2">
                                <line x1="500" y1="0" x2="500" y2="1000" stroke="#334155" stroke-dasharray="4,4" />
                                <line x1="0" y1="500" x2="1000" y2="500" stroke="#334155" stroke-dasharray="4,4" />
                            </g>

                            <g id="trailsLayer"></g>
                            <g id="orbitsLayer"></g>
                            <g id="aspectsLayer"></g>
                            <g id="planetsLayer"></g>
                        </svg>
                    </div>

                    <div
                        style="position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; background: rgba(15, 23, 42, 0.8); padding: 6px; border-radius: 8px; backdrop-filter: blur(4px); border: 1px solid #334155;">
                        <button class="btn-secondary" onclick="step(-30)">« 1M</button>
                        <button class="btn-secondary" onclick="step(-1)">‹ 1D</button>
                        <button id="playBtn" class="btn-primary" onclick="togglePlay()" style="width: 60px;">▶</button>
                        <button class="btn-secondary" onclick="step(1)">1D ›</button>
                        <button class="btn-secondary" onclick="step(30)">1M »</button>
                    </div>
                </div>

                <div style="margin-top: 16px; display: flex; gap: 12px; align-items: center;">
                    <span style="font-size: 11px; color: #94a3b8; white-space: nowrap;">Speed:</span>
                    <input type="range" min="1" max="100" value="20" oninput="speed = this.value" style="width: 100px;">
                    <span style="font-size: 11px; color: #94a3b8; margin-left: auto;">1900</span>
                    <input type="range" id="timeline" min="-36525" max="18262" value="0"
                        oninput="onTimelineChange(this.value)" style="flex-grow: 1;">
                    <span style="font-size: 11px; color: #94a3b8;">2050</span>
                </div>
            </div>

            <div class="card" style="display: flex; flex-direction: column; gap: 16px;">

                <div class="panel-section">
                    <div class="panel-title">Significant Alignments</div>
                    <select id="presetSelect" onchange="loadPreset(this.value)"
                        style="width: 100%; margin-bottom: 8px;">
                        <option value="">-- Select an Event --</option>
                        <option value="1962-02-05">1962: The Great Stellium (7 Bodies)</option>
                        <option value="1982-03-10">1982: The Jupiter Effect (95° Spread)</option>
                        <option value="2000-05-05">2000: The 5/5 Alignment</option>
                        <option value="2020-01-12">2020: Saturn-Pluto Conj (COVID)</option>
                        <option value="2040-09-08">2040: The Golden Conjunction</option>
                        <option value="2854-06-15">2854: The Ultimate Lineup</option>
                    </select>

                    <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                        <input type="date" id="datePicker" style="width: 100%;" onchange="goToDate(this.value)">
                        <button class="btn-secondary" onclick="goToDate('today')">Today</button>
                    </div>

                    <div id="alignmentScore"
                        style="background: #312e81; padding: 8px; border-radius: 4px; font-size: 11px; display: none;">
                        <strong>Alignment Score:</strong> <span id="scoreVal"
                            style="color: #fbbf24; font-weight: bold;">0%</span>
                        <div style="color: #94a3b8; margin-top: 2px;">Max Spread: <span id="spreadVal">0</span>°</div>
                    </div>
                </div>

                <div class="panel-section">
                    <div class="panel-title">Key Oppositions</div>
                    <div class="sep-grid">
                        <div class="sep-box" id="boxSunSat">
                            <div style="font-size: 10px; color: #94a3b8;">☉ SUN — ♄ SAT</div>
                            <div class="sep-val" id="valSunSat" style="color: #fbbf24;">0°</div>
                        </div>
                        <div class="sep-box" id="boxMoonUra">
                            <div style="font-size: 10px; color: #94a3b8;">☽ MOON — ♅ URA</div>
                            <div class="sep-val" id="valMoonUra" style="color: #22d3ee;">0°</div>
                        </div>
                    </div>
                </div>

                <div style="flex-grow: 1; display: flex; flex-direction: column; overflow: hidden;">
                    <div class="panel-title" style="display: flex; justify-content: space-between;">
                        <span>Events</span>
                        <select id="eventFilter" onchange="renderEvents()"
                            style="padding: 0 4px; height: 20px; font-size: 10px;">
                            <option value="all">All</option>
                            <option value="sun">Sun-Saturn</option>
                            <option value="moon">Moon-Uranus</option>
                        </select>
                    </div>
                    <div id="eventList" class="event-list"></div>
                </div>

                <div class="panel-section" style="border: none; padding: 0;">
                    <div class="panel-title">Planetary Status</div>
                    <div id="planetLegend"
                        style="font-size: 11px; display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const SVG_SIZE = 1000;
        const CENTER = SVG_SIZE / 2;
        const SCALE_FACTOR = 160; // Scale AU to pixels
        const J2000 = new Date('2000-01-01T12:00:00Z');

        // Orbital Elements (Simplified for speed but relatively accurate)
        // Period (days), Distance (AU), Initial Longitude (deg)
        const PLANETS = {
            Sun: { id: 'sun', name: 'Sun', per: 365.256, dist: 0, lon: 280.46, color: '#fbbf24', radius: 24, glow: true },
            Moon: { id: 'moon', name: 'Moon', per: 27.321, dist: 0.00257, lon: 218.31, color: '#e2e8f0', radius: 8 }, // Special handling
            Mercury: { id: 'mercury', name: 'Mercury', per: 87.969, dist: 0.387, lon: 252.25, color: '#a3a3a3', radius: 6 },
            Venus: { id: 'venus', name: 'Venus', per: 224.701, dist: 0.723, lon: 181.97, color: '#facc15', radius: 10 },
            Earth: { id: 'earth', name: 'Earth', per: 365.256, dist: 1.000, lon: 100.46, color: '#3b82f6', radius: 10 },
            Mars: { id: 'mars', name: 'Mars', per: 686.980, dist: 1.524, lon: 355.45, color: '#ef4444', radius: 8 },
            Jupiter: { id: 'jupiter', name: 'Jupiter', per: 4332.59, dist: 5.203, lon: 34.40, color: '#f97316', radius: 18 },
            Saturn: { id: 'saturn', name: 'Saturn', per: 10759.22, dist: 9.537, lon: 50.07, color: '#eab308', radius: 16 },
            Uranus: { id: 'uranus', name: 'Uranus', per: 30685.4, dist: 19.191, lon: 313.23, color: '#22d3ee', radius: 12 },
            Neptune: { id: 'neptune', name: 'Neptune', per: 60189.0, dist: 30.069, lon: 304.88, color: '#6366f1', radius: 12 },
            Pluto: { id: 'pluto', name: 'Pluto', per: 90560.0, dist: 39.482, lon: 238.92, color: '#a78bfa', radius: 6 }
        };

        // View Settings
        // In Geo mode, we artificially compress outer planet distances to fit screen
        // while maintaining angular integrity for aspects.
        const GEO_SCALES = {
            Sun: 0.6, Mercury: 0.2, Venus: 0.4, Mars: 0.8, Jupiter: 1.1,
            Saturn: 1.4, Uranus: 1.7, Neptune: 2.0, Pluto: 2.2
        };

        let state = {
            days: 0, // Days from J2000
            playing: false,
            speed: 20,
            view: 'geo', // 'geo' or 'helio'
            trailLength: 150,
            lastFrame: 0,
            history: {}, // For trails
            events: [],
            lastScannedDecade: null
        };

        // --- CORE PHYSICS ENGINE ---

        function getHelioPos(planetName, d) {
            const p = PLANETS[planetName];
            // Mean anomaly
            const M = (p.lon + (360 * (d / p.per))) % 360;
            const rad = M * Math.PI / 180;

            // Simple circular orbit (x, y)
            // Note: For full accuracy we'd add eccentricity, but this is sufficient for retrogrades
            return {
                x: Math.cos(rad) * p.dist,
                y: Math.sin(rad) * p.dist,
                lon: M
            };
        }

        function getGeoPos(planetName, d) {
            // 1. Get Earth Heliocentric
            const earth = getHelioPos('Earth', d);

            // 2. Get Object Heliocentric
            if (planetName === 'Sun') {
                // Sun from Earth is inverse of Earth from Sun
                return { x: -earth.x, y: -earth.y, dist: 1 };
            }

            if (planetName === 'Moon') {
                // Moon is special: It orbits Earth, carried by Earth
                // Geo position is just its simple geocentric orbit (approx)
                const m = PLANETS['Moon'];
                const M = (m.lon + (360 * (d / m.per))) % 360;
                const rad = M * Math.PI / 180;
                // Scale moon distance up for visibility in the UI (it's too close otherwise)
                const visDist = 0.15;
                return { x: Math.cos(rad) * visDist, y: Math.sin(rad) * visDist, dist: visDist };
            }

            const p = getHelioPos(planetName, d);

            // 3. Vector Subtraction (Planet - Earth)
            const dx = p.x - earth.x;
            const dy = p.y - earth.y;

            return { x: dx, y: dy, dist: Math.sqrt(dx * dx + dy * dy) };
        }

        function calculateScreenCoords(planetName, d) {
            let x, y, angleDeg;

            if (state.view === 'helio') {
                if (planetName === 'Moon') return null; // Don't show moon in helio
                if (planetName === 'Sun') return { x: 0, y: 0, angle: 0 };
                const pos = getHelioPos(planetName, d);
                // Logarithmic visual scaling for outer planets in helio view
                const visualDist = Math.pow(PLANETS[planetName].dist, 0.6) * 60;
                const angle = Math.atan2(pos.y, pos.x);
                x = Math.cos(angle) * visualDist;
                y = Math.sin(angle) * visualDist;
                angleDeg = (angle * 180 / Math.PI + 360) % 360;
            } else {
                // Geocentric
                if (planetName === 'Earth') return { x: 0, y: 0, angle: 0 };
                const pos = getGeoPos(planetName, d);
                const angle = Math.atan2(pos.y, pos.x);

                // Use fixed scales for visual clarity in Geocentric mode
                // so planets don't overlap or fly off screen
                let r = GEO_SCALES[planetName] * 180;
                if (planetName === 'Moon') r = 60; // Fixed orbit for UI

                x = Math.cos(angle) * r;
                y = Math.sin(angle) * r;
                angleDeg = (angle * 180 / Math.PI + 360) % 360;
            }

            // Flip Y for screen coords
            return { x: CENTER + x, y: CENTER - y, angle: angleDeg };
        }

        // --- RENDERING ---

        function init() {
            createStars();
            createZodiac();

            // Initialize history arrays
            Object.keys(PLANETS).forEach(k => state.history[k] = []);

            // Initial scan based on starting date
            scanEventsForView(0);

            // Init Date Picker
            document.getElementById('datePicker').value = J2000.toISOString().split('T')[0];

            update(0); // Start at J2000
        }

        function createStars() {
            const g = document.getElementById('starsLayer');
            let html = '';
            for (let i = 0; i < 300; i++) {
                const x = Math.random() * SVG_SIZE;
                const y = Math.random() * SVG_SIZE;
                const r = Math.random() * 1.5;
                const op = Math.random() * 0.7 + 0.3;
                html += `<circle cx="${x}" cy="${y}" r="${r}" fill="white" opacity="${op}" />`;
            }
            g.innerHTML = html;
        }

        function createZodiac() {
            const g = document.getElementById('zodiacLayer');
            const signs = ['♈', '♉', '♊', '♋', '♌', '♍', '♎', '♏', '♐', '♑', '♒', '♓'];
            let html = '';
            signs.forEach((s, i) => {
                const deg = i * 30;
                const rad = (deg + 15) * Math.PI / 180;
                // Flip Y for SVG
                const x = CENTER + Math.cos(rad) * 460;
                const y = CENTER - Math.sin(rad) * 460;

                // Line dividers
                const lineRad = deg * Math.PI / 180;
                const x1 = CENTER + Math.cos(lineRad) * 440;
                const y1 = CENTER - Math.sin(lineRad) * 440;
                const x2 = CENTER + Math.cos(lineRad) * 480;
                const y2 = CENTER - Math.sin(lineRad) * 480;

                html += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="#334155" />`;
                html += `<text x="${x}" y="${y}" text-anchor="middle" dominant-baseline="middle" fill="#64748b" font-size="20">${s}</text>`;
            });
            g.innerHTML = html;
        }

        function update(timestamp) {
            if (state.playing) {
                if (!state.lastFrame) state.lastFrame = timestamp;
                const delta = timestamp - state.lastFrame;
                if (delta > 16) { // Cap at ~60fps
                    state.days += (state.speed / 10) * (delta / 16);
                    state.lastFrame = timestamp;
                    render();
                }
                requestAnimationFrame(update);
            }
        }

        function render() {
            const d = state.days;
            const date = new Date(J2000.getTime() + d * 86400000);

            // 1. Update UI Text
            document.getElementById('dateDisplay').textContent = date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: '2-digit' });
            document.getElementById('timeline').value = d;

            // Era Badge
            const y = date.getFullYear();
            const badge = document.getElementById('eraBadge');
            if (y < 1929) { badge.textContent = "Roaring 20s"; badge.style.background = "#8b5cf6"; }
            else if (y < 1939) { badge.textContent = "Depression"; badge.style.background = "#ef4444"; }
            else if (y < 1945) { badge.textContent = "WWII"; badge.style.background = "#b91c1c"; }
            else if (y > 2020) { badge.textContent = "Future"; badge.style.background = "#0ea5e9"; }
            else { badge.textContent = "Modern"; badge.style.background = "#3b82f6"; }

            // 2. Update Planets & Trails
            let planetsHtml = '';
            let trailsHtml = '';
            let legendHtml = '';
            const positions = {};

            // Center Object (Earth or Sun)
            if (state.view === 'geo') {
                planetsHtml += `<circle cx="${CENTER}" cy="${CENTER}" r="8" fill="#3b82f6" filter="url(#glow)" />`;
                planetsHtml += `<text x="${CENTER}" y="${CENTER + 20}" fill="#3b82f6" font-size="10" text-anchor="middle">Earth</text>`;
            } else {
                planetsHtml += `<circle cx="${CENTER}" cy="${CENTER}" r="14" fill="url(#sunGradient)" filter="url(#glow)" />`;
            }

            for (const [key, p] of Object.entries(PLANETS)) {
                if (state.view === 'helio' && (key === 'Sun' || key === 'Moon')) continue;
                if (state.view === 'geo' && key === 'Earth') continue;

                const pos = calculateScreenCoords(key, d);
                positions[key] = pos; // Store for aspect calc

                // Update History for Trails
                if (state.trailLength > 0) {
                    state.history[key].push({ x: pos.x, y: pos.y });
                    if (state.history[key].length > state.trailLength) state.history[key].shift();

                    if (state.history[key].length > 1) {
                        const points = state.history[key].map(pt => `${pt.x},${pt.y}`).join(' ');
                        trailsHtml += `<polyline points="${points}" class="trail" stroke="${p.color}" stroke-opacity="0.4" stroke-width="1" />`;
                    }
                }

                // Detect Retrograde (Simple angular velocity check)
                let isRetro = false;
                if (state.history[key].length > 2) {
                    const h = state.history[key];
                    const prev = h[h.length - 2];
                    const curr = h[h.length - 1];
                    // Very rough visual check relative to center in 2D plane logic
                    // Real check is dLon/dt < 0
                    // We'll rely on the visual loop for now, but update Legend
                }

                // Draw Planet
                planetsHtml += `
                    <g class="planet-grp" onmouseenter="showTooltip('${key}', ${pos.angle.toFixed(1)})" onmouseleave="hideTooltip()">
                        <circle cx="${pos.x}" cy="${pos.y}" r="${p.radius / 2}" fill="${p.color}" class="planet-circle" ${p.glow ? 'filter="url(#glow)"' : ''} />
                        <text x="${pos.x}" y="${pos.y + 12}" fill="${p.color}" font-size="9" text-anchor="middle">${p.name}</text>
                    </g>
                `;

                // Update Legend
                legendHtml += `
                    <div style="display: flex; align-items: center; justify-content: space-between; color: #cbd5e1;">
                        <span style="color:${p.color}">● ${p.name}</span>
                        <span>${Math.floor(pos.angle)}°</span>
                    </div>
                `;
            }

            document.getElementById('planetsLayer').innerHTML = planetsHtml;
            document.getElementById('trailsLayer').innerHTML = trailsHtml;
            document.getElementById('planetLegend').innerHTML = legendHtml;

            // 3. Aspects (Sun-Saturn & Moon-Uranus)
            if (positions.Sun && positions.Saturn) updateAspectLine(positions.Sun, positions.Saturn, 'Sun', 'Saturn', 'valSunSat', 'boxSunSat');
            if (positions.Moon && positions.Uranus) updateAspectLine(positions.Moon, positions.Uranus, 'Moon', 'Uranus', 'valMoonUra', 'boxMoonUra');

            highlightEvents(d);
        }

        function updateAspectLine(p1, p2, n1, n2, valId, boxId) {
            // Calc separation
            let sep = Math.abs(p1.angle - p2.angle);
            if (sep > 180) sep = 360 - sep;

            const lineId = `${n1}-${n2}`;
            let line = document.getElementById(lineId);

            // Draw Opposition Line
            const g = document.getElementById('aspectsLayer');
            // Rebuild aspects layer every frame is okay for this count
            // Actually let's just inject line if huge aspect

            const isOpp = sep > 175;
            const elVal = document.getElementById(valId);
            const elBox = document.getElementById(boxId);

            elVal.innerText = sep.toFixed(1) + '°';

            if (isOpp) {
                elBox.classList.add('active');
                if (!document.getElementById('line-' + lineId)) {
                    // This is inefficient in render loop, ideally use existing DOM
                    g.innerHTML += `<line id="line-${lineId}" x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="white" stroke-dasharray="4" opacity="0.5" />`;
                }
            } else {
                elBox.classList.remove('active');
            }
        }

        // --- CONTROLS ---

        function togglePlay() {
            state.playing = !state.playing;
            document.getElementById('playBtn').innerText = state.playing ? '❚❚' : '▶';
            if (state.playing) requestAnimationFrame(update);
        }

        function step(deltaDays) {
            state.playing = false;
            document.getElementById('playBtn').innerText = '▶';
            state.days += deltaDays;
            render();
        }

        function setViewMode(mode) {
            state.view = mode;
            // Clear history so trails don't look crazy during switch
            Object.keys(PLANETS).forEach(k => state.history[k] = []);

            document.getElementById('viewGeo').className = mode === 'geo' ? 'btn-outline active' : 'btn-outline';
            document.getElementById('viewHelio').className = mode === 'helio' ? 'btn-outline active' : 'btn-outline';
            render();
        }

        function setTrailLength(val) {
            state.trailLength = parseInt(val);
            Object.keys(PLANETS).forEach(k => state.history[k] = []);
        }

        function onTimelineChange(val) {
            state.days = parseInt(val);
            state.playing = false;
            document.getElementById('playBtn').innerText = '▶';
            Object.keys(PLANETS).forEach(k => state.history[k] = []); // Clear trails
            render();
        }

        function goToDate(val) {
            if (!val) return;
            if (val === 'today') {
                const now = new Date();
                const diff = (now - J2000) / 86400000;
                state.days = diff;
                document.getElementById('datePicker').value = now.toISOString().split('T')[0];
            } else {
                const d = new Date(val);
                if (isNaN(d.getTime())) return;
                const diff = (d - J2000) / 86400000;
                state.days = diff;
            }
            state.playing = false;
            Object.keys(PLANETS).forEach(k => state.history[k] = []);
            render();
        }

        // --- TOOLTIP ---
        function showTooltip(name, angle) {
            if (state.playing) togglePlay(); // Pause on hover
            const t = document.getElementById('tooltip');
            t.style.opacity = 1;
            t.innerHTML = `<strong>${name}</strong><br>Lon: ${angle}°`;

            // Move tooltip to mouse (requires mouse event, simple hack here:)
            document.onmousemove = function (e) {
                // Get container rect
                const rect = document.querySelector('.sim-container').getBoundingClientRect();
                t.style.left = (e.clientX - rect.left + 15) + 'px';
                t.style.top = (e.clientY - rect.top) + 'px';
            }
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.opacity = 0;
            document.onmousemove = null;
        }

        // --- EVENTS ENGINE --- (REPLACED BY DYNAMIC SCANNER)
        /*
        function precalcEvents() {
           // Legacy removed
        }
        */

        function renderEvents() {
            const filter = document.getElementById('eventFilter').value;
            const list = document.getElementById('eventList');

            const filtered = state.events.filter(e => filter === 'all' || e.type === filter);

            // Sort by proximity to current date? Or just Chronological?
            // Let's show chronological

            let html = '';
            filtered.forEach(e => {
                const date = new Date(J2000.getTime() + e.d * 86400000);
                const dateStr = date.toLocaleDateString();
                html += `<div class="event-item ${e.color}" id="evt-${e.d}" onclick="goToEvent(${e.d})">
                    <span>${e.label}</span>
                    <span style="opacity:0.6">${dateStr}</span>
                </div>`;
            });
            list.innerHTML = html;
        }

        function highlightEvents(currentDay) {
            // Find closest event
            // Remove old active
            const old = document.querySelector('.event-item.active');
            if (old) old.classList.remove('active');

            // Find one within 10 days
            const match = state.events.find(e => Math.abs(e.d - currentDay) < 5);
            if (match) {
                const el = document.getElementById(`evt-${match.d}`);
                if (el) {
                    el.classList.add('active');
                    el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }

        window.goToEvent = function (d) {
            state.days = d;
            state.playing = false;
            Object.keys(PLANETS).forEach(k => state.history[k] = []);
            render();
        }

        // --- NEW ALIGNMENT LOGIC ---

        function loadPreset(dateStr) {
            if (!dateStr) return;
            goToDate(dateStr);

            // Auto-switch view for best effect
            // 1962 looks best in Geo, 1982 looks best in Helio
            if (dateStr.includes('1982') || dateStr.includes('2040')) {
                setViewMode('helio');
            } else {
                setViewMode('geo');
            }

            setTimeout(analyzeAlignment, 100); // Wait for render
        }

        // Calculate how "bunched up" the planets are
        function analyzeAlignment() {
            const bodies = ['Sun', 'Moon', 'Mercury', 'Venus', 'Mars', 'Jupiter', 'Saturn'];
            const angles = [];

            // 1. Collect angles based on current view
            if (state.view === 'geo') {
                bodies.forEach(b => {
                    const pos = calculateScreenCoords(b, state.days);
                    if (pos) angles.push(pos.angle);
                });
            } else {
                // In helio, we exclude Sun/Moon, include Earth
                ['Earth', 'Mercury', 'Venus', 'Mars', 'Jupiter', 'Saturn', 'Uranus'].forEach(b => {
                    const pos = calculateScreenCoords(b, state.days);
                    if (pos) angles.push(pos.angle);
                });
            }

            // 2. Sort angles
            angles.sort((a, b) => a - b);

            // 3. Find the smallest arc containing all planets
            // We must check every gap between planets to handle the 360/0 crossover
            let maxGap = 0;
            for (let i = 0; i < angles.length; i++) {
                const current = angles[i];
                const next = angles[(i + 1) % angles.length];
                let gap = next - current;
                if (gap < 0) gap += 360; // Handle circle wrap
                if (gap > maxGap) maxGap = gap;
            }

            // The spread is the circle minus the largest gap
            const spread = 360 - maxGap;

            // 4. Update UI
            const ui = document.getElementById('alignmentScore');
            const scoreVal = document.getElementById('scoreVal');
            const spreadVal = document.getElementById('spreadVal');

            ui.style.display = 'block';
            spreadVal.textContent = spread.toFixed(1);

            // "Score" is arbitrary: 0 spread = 100%, 180 spread = 0%
            let score = Math.max(0, 100 - (spread / 1.8));
            scoreVal.textContent = score.toFixed(0) + '%';

            if (spread < 20) {
                ui.style.background = '#4c1d95'; // Deep purple for super rare
                scoreVal.innerHTML += " (LEGENDARY)";
            } else if (spread < 90) {
                ui.style.background = '#3730a3';
            } else {
                ui.style.background = '#1e1b4b';
            }
        }

        // --- DYNAMIC EVENT SCANNER ---

        function scanEventsForView(currentDay) {
            const date = new Date(J2000.getTime() + currentDay * 86400000);
            const currentYear = date.getFullYear();
            const decade = Math.floor(currentYear / 10) * 10;

            // Optimization: Only re-scan if we've moved to a new decade
            if (state.lastScannedDecade === decade) return;
            state.lastScannedDecade = decade;

            console.log(`Scanning events for the ${decade}s...`);
            state.events = [];

            // Calculate start/end days for this decade relative to J2000
            const startMs = new Date(decade, 0, 1).getTime();
            const endMs = new Date(decade + 10, 0, 1).getTime();
            const startD = (startMs - J2000.getTime()) / 86400000;
            const endD = (endMs - J2000.getTime()) / 86400000;

            // Scan the decade
            for (let d = startD; d < endD; d += 2) { // Step 2 days for speed
                // Sun-Saturn Opposition (Earth between Sun and Saturn)
                // We use simple longitude math for speed here
                const sunLon = (PLANETS.Sun.lon + (360 * d / 365.25)) % 360;
                const satLon = (PLANETS.Saturn.lon + (360 * d / 10759)) % 360;
                const diff = Math.abs(sunLon - satLon);

                // Check for Opposition (180)
                if (Math.abs(diff - 180) < 1.5) {
                    // Check if we already added a nearby event (deduplication)
                    if (!state.events.some(e => Math.abs(e.d - d) < 10 && e.type === 'sun')) {
                        state.events.push({ d: d, type: 'sun', label: 'Sun-Saturn Opposition', color: 'sun' });
                    }
                }

                // Moon-Uranus (Every 27 days) - Only scan if not too many events
                if (state.events.length < 50) {
                    const moonLon = (PLANETS.Moon.lon + (360 * d / 27.32)) % 360;
                    const uraLon = (PLANETS.Uranus.lon + (360 * d / 30685)) % 360;
                    const diffM = Math.abs(moonLon - uraLon);
                    if (diffM < 2 || Math.abs(diffM - 180) < 2) {
                        if (!state.events.some(e => Math.abs(e.d - d) < 5 && e.type === 'moon')) {
                            state.events.push({ d: d, type: 'moon', label: 'Moon-Uranus Align', color: 'moon' });
                        }
                    }
                }
            }

            // Sort chronologically
            state.events.sort((a, b) => a.d - b.d);
            renderEvents();
        }

        // Hook analysis into the render loop so it updates as you play
        const originalRender = render;
        render = function () {
            scanEventsForView(state.days);
            originalRender();
            // Only analyze every 5 frames to save CPU
            if (Math.floor(state.days) % 5 === 0 || !state.playing) {
                analyzeAlignment();
            }
        }

        // Start
        init();

    </script>
</body>

</html>